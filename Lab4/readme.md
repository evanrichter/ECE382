# Lab 4 - C - "Etch-a-Sketch and Pong"

## Objectives

You've spent the last 5 lessons transitioning from programming in assembly language to C.  In this lab, you'll use C to create an etch-a-sketch-type program that utilizes some subroutines from Lab 3.  You'll be expected to write clean, maintainable, modular code that is committed regularly to Git.

## Prelab

### Data types

Go to page 76 of the C Compiler User's Guide to complete the following table. For the type, fill in data type that produces a variable of the given size. For max/min values, write in the maximum and minimum values that can be represented with the data type in that row.  Two examples have been given.

| Size | Signed/Unsigned | Type | Min value | Max value |
| :---: | :---: | :---: | :---: | :---: |
| 8-bit | unsigned | unsigned char | 0|255 |
| 8-bit | signed | signed char|-128 |127 |
| 16-bit | unsigned | unsigned short | 0|65 535 |
| 16-bit | signed | int| -32 768|32 767 |
| 32-bit | unsigned | unsigned long|0 | 4 294 967 295|
| 32-bit | signed |signed long | -2 147 483 648 | 2 147 483 647|
| 64-bit | unsigned | unsigned long long |0 |18 446 744 073 709 551 615 |
| 64-bit | signed |signed long long | -9 223 372 036 854 775 808| 9 223 372 036 854 775 807|

When writing embedded C code, it is always a good idea to separate your code from the architecture as much as possible because to make the code easier to change. This is why it is better to:
- use the peripheral register names in your code (e.g. P2IN) rather than their address (e.g. 0x28).
- use peripheral register field names in your code

Because space is limited on microcontrollers, it is a common practice to use variables with a range suitable for the task at hand. Unfortunately, there is no standard among C compilers between the basic data types like char, short, long and the number of bits in the underlying data representation. Furthermore, when writing and reading code, it is not readily apparent how many bits are in a short or long variable. Consequently, we will write our programs using typed definitions that provide an obvious connection between the data type and the number of bits in the representation.

Start by consulting the [Typedef Wikipedia page](http://en.wikipedia.org/wiki/Typedef). Next, fill in the following chart with the appropriate C code definitions.

| Type | Meaning | C typedef declaration |
| :---: | ---: | :--- |
| int8 | unsigned 8-bit value | typedef unsigned char int8; |
| sint8 | signed 8-bit value |  typedef signed char sint8; |
| int16 | unsigned 16-bit value | typedef unsigned short int16;|
| sint16 | signed 16-bit value |  typedef signed short sint16;|
| int32 | unsigned 32-bit value | typedef unsigned long int32; |
| sint32 | signed 32-bit value | typedef signed long sint32; |
| int64 | unsigned 64-bit value | typedef unsigned long long int64; |
| sint64 | signed 64-bit value | typedef signed long long sint64; |

### Calling/Return Convention

Make a project around simpleLab4.c. While the functioning of the program is not really that important, let's first take some time to understand what is going on in this program before we look at the underlying assembly language. Use CCS to step through the program and examine the a, b, c, d, e variables in main, just after the call to the function func in line 16.

| Iteration | a | b | c | d | e |
| :---: | :---: | :---: | :---: | :---:| :---: |
| 1st | 1 | 2 | 3 | 4 | 2 |
| 2nd | 10|9  |8  |7  |8  |
| 3rd | 16|15 |14 |13 |14 |
| 4th |22 |21 |20 |19 |20 |
| 5th | 28|27 |26 |25 |26 |

Now examine the assembly code generated by the compiler by selecting the View -> Disassembly menu item. You should see the disassembly window as a selectable tab in the subwindow where your registers are displayed. To fill in the following table with the appropriate values, you have a few tasks:
- Firstly, find the code for the function `func` and write down the starting and ending address in the table below.
- Next, identify which registers are used to pass the input parameters from main to the function. Write their identities below. If it is not clear which register holds which input parameter, test it out!  Go ahead and change the code, so that `func` only has one input parameter, recompile the code, and then examine the assembly.
- Finally, determine which register is used to return the value from func to main.

| Parameter | Value Sought |
| :---: | :---: |
| Starting address of `func` | xC2C8 |
| Ending address of `func` |xC326 |
| Register holding w | r12|
| Register holding x | r13|
| Register holding y | r14|
| Register holding z | r15|
| Register holding return value | r12|

### Cross language build constructs

Answer the following questions:

What is the role of the `extern` directive in a .c file?  Hint: check out the [external variable](http://en.wikipedia.org/wiki/External_variable) Wikipedia page.


*It describes a variable that has been allocated to memory in another file.*



What is the role of the `.global` directive in an .asm file (used in lines 28-32)?  Hint: reference section 2.6.2 in the MSP 430 Assembly Language Tools v4.3 User's Guide.


*`.global` can either define or reference a variable that is used by multiple files. The compiler chooses where the variable is actually allocated.*

## Code Discussion

### B Functionality
The code below was the main function that fulfilled the requirement for B functionality. It is a function that inputs the ball's current position, velocity, and upper limit. The output is a `SignedInt8Pair` which is a tuple of two signed 8-bit values. The output notifies the calling function of the ball's new position and new velocity, which changes on collision.

```
SignedInt8Pair move1d(sint8 position, sint8 velocity, sint8 upperbound) {
	SignedInt8Pair c;
	if (position + velocity <= upperbound) {
		if (position + velocity >= 0) {
			c.x = position + velocity;
			c.y = velocity;
		} else {
			c.x = 0;
			c.y = -velocity;
		}
	} else {
		c.x = upperbound;
		c.y = -velocity;
	}
	return c;
}
```

### A Functionality
For A functionality, a special case arises for collisions on the left wall. One posibility is that the ball rebounds off the paddle and the game continues as normal. Another, is that the player misses and the game ends. I took the opportunity in the former case to print a capital 'L' on the screen to let the player know he lost. An infinite loop afterward was a succinct way to stop other things from happening after gameover.

```
//when ball hits left row, check collision
		if (position.x<=0) {
			if (position.y < paddle || position.y > paddle + PADDLE_SIZE){
				//game over, taunt player
				clearDisplay();
				drawBlock(1,4);
				drawBlock(2,4);
				drawBlock(3,4);
				drawBlock(4,4);
				drawBlock(4,5);
				drawBlock(4,6);
				while (TRUE);
			} else {
				//collision, rebound ball
				velocity.x = -velocity.x;
			}
		}
```
The following code is the input checking for moving the paddle. It would have been straight forward, but for better playability I chose to delay input checking on a different interval than game update speed.
```
cnt=0;
		for(;cnt<1000;cnt++){
			cnt2=0;
			for(;cnt2<95;cnt2++);
			if (button_press==FALSE){
				if (UP_BUTTON == 0 && paddle > 0){
					paddle--;
					button_press=TRUE;
				} else if (DOWN_BUTTON == 0
						   && (paddle+PADDLE_SIZE) < Y_UPPER_BOUND){
					paddle++;
					button_press=TRUE;
				}
			}
		}
		if (button_press==TRUE){
			if (inputDelay >= 2 ){
				inputDelay=0;
				button_press=FALSE;
			} else {
				inputDelay++;
			}
		}
```

### Extra Credit Ball
This functionality required an additional `extern` function description, and a corresponding subroutine in `nokia.asm`. In C below, the `drawCircle` is equivalent to `drawBlock()` in practice.
```
extern void drawCircle(unsigned char row, unsigned char col);
...
void main(void) {
...
  drawCircle(position.y,position.x);
...
}
```
In assembly, I defined the circle bitmap explicitly. I took some artistic liberty in this functionality and made a "circle". It looks best whilst squinting. The assembly code takes advantage of the automatic page increase function of the Nokia display. I only had to sequentially write the 8-bit pages.

```
drawCircle:
	push	R12
	push	R13

	rla.w	R13					; the column address needs multiplied
	rla.w	R13					; by 8in order to convert it into a
	rla.w	R13					; pixel address.
	call	#setAddress			; move cursor to upper left corner of block

	mov		#1, R12
	mov		#0x08, R13
	call	#writeNokiaByte
	mov		#0x3C, R13
	call	#writeNokiaByte
	mov		#0x7E, R13
	call	#writeNokiaByte
	mov		#0xFE, R13
	call	#writeNokiaByte
	mov		#0x7F, R13
	call	#writeNokiaByte
	mov		#0x7E, R13
	call	#writeNokiaByte
	mov		#0x3c, R13
	call	#writeNokiaByte
	mov		#0x10, R13
	call	#writeNokiaByte

	pop		R13
	pop		R12

	ret
```
## Debugging
Getting the initial display of a bouncing block to show correctly was a slight problem. At first I was not separating the `clearDisplay` and `drawBlock` calls by any delay. Implemented this way, the block appeared for a barely perceptible time. It looked incredibly faint. I fixed it by clearing, drawing, *then* waiting.

One bug that required a lot of tweaking was finding the right balance of input checking to game speed, and then finding the right amount of game 'ticks' to accept the player's input again. It required two extra counter variables, `cnt2` and `inputDelay`, where the previous implementations only required one counter, `cnt`.

## Conclusion
I learned in this lab that coding in C is much more readable than assembly. It is worth the slight learning curve to transition to programming mostly in C while supplementing in assembly. In retrospect, it would have been simpler to implement the inputs as hardware interrupts instead of discrete polling intervals. It would be cleaner to write, easier to understand, and have less potential for bugs.

## Grading

| Item | Grade | Points | Out of | Date | Due |
|:-: | :-: | :-: | :-: | :-: |
| Prelab | **On-Time:** 0 ---- Check Minus ---- Check ---- Check Plus | | 10 | | BOC L23 |
| Required Functionality | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days| | 30 | | COB L24 |
| B Functionality | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days| | 15 | | COB L24 |
| A Functionality | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days| | 10 | | COB L24 |
| Bonus Functionality | **On-Time** -------------------------------------------------------------------- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days| | 5 each for circle, fine, and inverted | | COB L24 |
| Lab Notebook | **On-Time:** 0 ---- Check Minus ---- Check ---- Check Plus ----- **Late:** 1Day ---- 2Days ---- 3Days ---- 4+Days| | 35 | | COB L25 |
| **Total** | | | **100** | | | |
